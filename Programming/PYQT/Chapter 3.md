# Chapter 3 - Login GUI (with signup page)

## Buttons and Events and QLineEdit and QTextEdit
```Python
import sys
from PyQt5.QtWidgets import (QApplication, QWidget, 
QLabel, QPushButton , QLineEdit)

class ButtonWindow(QWidget):
	def __init__(self):
		super().__init__() # create default constructor for QWidget
		self.initializeUI()
		
	def initializeUI(self):
		"""
		Initialize the window and display its contents to the
		screen.
		"""
		self.setGeometry(100, 100, 200, 150)
		self.setWindowTitle('QPushButton Widget')
		self.displayButton() # call our displayButton function
		self.show()
		
	def displayButton(self):
		'''
		Setup the button widget.
		'''
		name_label = QLabel(self)
		name_label.setText("Don't push the button.")
		name_label.move(60, 30) # arrange label
		button = QPushButton('Push Me', self)
		button.clicked.connect(self.buttonClicked)
		button.move(80, 70) # arrange button
		
		input_line = QLineEdit(self)
		input_line.move(80 , 100) #arrange line_input
		
	def buttonClicked(self):
		'''
		Print message to the terminal,
		and close the window when button is clicked.
		'''
		print("The window has been closed.")
		self.close()
		
# Run program
if __name__ == '__main__':
	app = QApplication(sys.argv)
	window = ButtonWindow()
	sys.exit(app.exec_())
```

- Here the `QPushButton` widget creates a simple button which sends a signal/event when pushed.
	- This event can be used to connect it to function like in `button.clicked.connect(self.buttonClicked)` , notice that the function isnt called in the parenthesis.
- There are also other signals like `pressed()` , `released()` and `toggeled()`

- `input_line` is a `QLineEdit` widget used for entering data in a single line , especially for forms.
	- Methods like `text()` and `clear()` can be used to get the text from the `QLineEdit` widget and clear text from the widget.
- `QTextEdit` is similar to `QLineEdit` only difference is that it supports a large amount of text.
---


## Events , Signals and Slots 
### Events 
PyQt5 is an **event** driven GUI; It means that it listens for user events like pressing a button or cursor movement or any other user input until it is closed.

The `app.exec_()` method starts the GUI and listens for the user input/events. 

### Signals and Slots
Signals are the events that occur when there is a change in a widget.
For example checking a checkbox widget or pressing on a button.
These type of events are generated by pyqt and can be used to connect/trigger other functions/Slots.

Slots are basically the methods called in response to a Signal.

```python
import sys
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel,
    QLineEdit, QPushButton
)


class loginGUI(QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 400, 200)
        self.setWindowTitle("LOGIN GUI WID BUTTONS")
        self.displayWidgets()

        self.show()

    def displayWidgets(self):
        QLabel("Enter YOUR DETAILS BELOW")
        name_label = QLabel("Name :").move(70, 50)
        self.name_entry = QLineEdit(self)
        self.name_entry.setAlignment(Qt.AlignLeft)
        self.name_entry.move(130, 50)
        self.name_entry.resize(200,  20)

        self.clear_button = QPushButton("Clear", self)
        self.clear_button.clicked.connect(self.clearEntries)
        self.clear_button.move(160, 110)

    def clearEntries(self):
        sender = self.sender()
        if sender.text() == "Clear":
            self.name_entry.clear()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = loginGUI()
    sys.exit(app.exec_())

```

Here `Qt.AlignLeft` is used to position the text inside the *QLineEdit Widget*.
The `self.sender()` method helps in recieving the signals generated and the `sender.text()` method allows us to get the text from the widget through which the signal originated.  
**Note**: When connecting a function/Slot to a Signal it the function must not be called in the connect method like 
`self.clear_button.clicked.connect(self.clearEntries)`


## MessageBox Widgets
```python
import sys
from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel,
    QMessageBox, QLineEdit, QPushButton)

from PyQt5.QtGui import QFont


class showMessageBox(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 400, 200)
        self.setWindowTitle("Message Box Example Window")
        self.showWidgets()
        self.show()

    def showWidgets(self):
        header_label = QLabel("Author Catalogue", self)
        header_label.move(20, 20)
        header_label.setFont(QFont("Space Mono Nerdfont", 20))

        sub_header_label = QLabel(
            "Enter the name of the author you are searching for", self)
        sub_header_label.move(30, 70)

        name_label = QLabel("Name:", self)
        name_label.move(30, 110)

        self.name_entry = QLineEdit(self)
        self.name_entry.move(80, 110)
        self.name_entry.resize(190, 20)
        self.name_entry.setPlaceholderText("FirstName LastName")

        search_button = QPushButton("Search",  self)
        search_button.move(150, 160)
        search_button.clicked.connect(self.displayMessageBox)

    def displayMessageBox(self):
        messagebox = QMessageBox()
        if self.name_entry.text() in ["Guacamole", "Jeebus", "Yeetus"]:
            messagebox.information(
                self, "Author Found", "Author found in catalogue",
                QMessageBox.Ok, QMessageBox.Ok)

        else:
            messagebox.question(self, "Author Not Found", "Author Found in catalogue \nDo you wish to continue", 
                    QMessageBox.Yes | QMessageBox.No)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = showMessageBox()
    sys.exit(app.exec_())
```

`QMessageBox` has multiple boxes for the varying need of the user.
Here information and question type box is used.
The argument is as follows
(Parent_object , Header , Text , Buttons)
The type of buttons can be Yes , No , Reset , Open and Save.

## Login GUI 
```python
import sys
from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel,
    QMessageBox, QLineEdit, QPushButton,
    QCheckBox)

from PyQt5.QtGui import QFont
from PyQt5.QtCore import Qt


class loginGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 400, 230)
        self.setWindowTitle("Login GUI")
        self.displayWidgets()
        self.show()

    def displayWidgets(self):
        header_label = QLabel("Login", self)
        header_label.setFont(QFont("Space Mono Nerdfont", 15))
        header_label.move(140, 10)

        QLabel("username :", self).move(30, 60)  # Username label
        self.user_entry = QLineEdit(self)
        self.user_entry.move(120, 60)
        self.user_entry.resize(150, 20)

        QLabel("password :", self).move(30, 90)  # password label
        self.pass_entry = QLineEdit(self)
        self.pass_entry.move(120, 90)
        self.pass_entry.resize(150, 20)
        self.pass_entry.setEchoMode(QLineEdit.Password)

        show_pass_cb = QCheckBox("show password", self)
        show_pass_cb.move(120, 110)
        show_pass_cb.stateChanged.connect(self.togglePasswordVisibility)

        login_button = QPushButton("Login", self)
        login_button.resize(150, 30)
        login_button.move(120, 140)
        login_button.clicked.connect(self.checkUserInfo)

    def togglePasswordVisibility(self, state):
        if state == Qt.Checked:
            self.pass_entry.setEchoMode(QLineEdit.Normal)
        else:
            self.pass_entry.setEchoMode(QLineEdit.Password)

    def checkUserInfo(self):
        messagebox = QMessageBox()
        if self.user_entry.text() in ["A", "AA", "AAA"] and self.pass_entry.text() in ["B", "BB", "BBB"]:
            messagebox.information(
                self, "Login Successful", "Login Successful", QMessageBox.Ok)
        else:
            messagebox.critical(self, "Login Unsuccessful",
                                "Login Unsuccessful", QMessageBox.Ok)

    def closeEvent(self, event):
        messagebox = QMessageBox()
        quit_message = messagebox.question(
            self, "Quit", "", QMessageBox.No | QMessageBox.Yes)
        if quit_message == QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = loginGUI()
    sys.exit(app.exec_())
```

`setEchoMode` method on the *QLineEdit* widget changes how the text is displayed , `setEchoMode(QLineEdit.Password)` will change it to display text as dots. 

The *QCheckBox* `stateChanged` method is like `clicked` in the use case of *QLineEdit*.

*closeEvent* is a builtin method which prompts the user for confirmation when closing the app. (The name of the method must not be changed.)
